/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendServicesNamedPortsObservation struct {
}

type BackendServicesNamedPortsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Ports []*string `json:"ports" tf:"ports,omitempty"`
}

type DiskInitializeParamsObservation struct {
}

type DiskInitializeParamsParameters struct {

	// +kubebuilder:validation:Optional
	DiskSizeGb *string `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// +kubebuilder:validation:Required
	SourceImage *string `json:"sourceImage" tf:"source_image,omitempty"`
}

type GkeBackendServicesObservation struct {
}

type GkeBackendServicesParameters struct {

	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// +kubebuilder:validation:Optional
	NamedPorts []BackendServicesNamedPortsParameters `json:"namedPorts,omitempty" tf:"named_ports,omitempty"`

	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`

	// +kubebuilder:validation:Required
	ServiceName *string `json:"serviceName" tf:"service_name,omitempty"`
}

type GkeDiskObservation struct {
}

type GkeDiskParameters struct {

	// +kubebuilder:validation:Optional
	AutoDelete *bool `json:"autoDelete,omitempty" tf:"auto_delete,omitempty"`

	// +kubebuilder:validation:Optional
	Boot *bool `json:"boot,omitempty" tf:"boot,omitempty"`

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	InitializeParams []DiskInitializeParamsParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// +kubebuilder:validation:Optional
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type GkeGpuObservation struct {
}

type GkeGpuParameters struct {

	// +kubebuilder:validation:Required
	Count *int64 `json:"count" tf:"count,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type GkeInstanceTypesCustomObservation struct {
}

type GkeInstanceTypesCustomParameters struct {

	// +kubebuilder:validation:Required
	MemoryGib *int64 `json:"memoryGib" tf:"memory_gib,omitempty"`

	// +kubebuilder:validation:Required
	Vcpu *int64 `json:"vcpu" tf:"vcpu,omitempty"`
}

type GkeIntegrationDockerSwarmObservation struct {
}

type GkeIntegrationDockerSwarmParameters struct {

	// +kubebuilder:validation:Required
	MasterHost *string `json:"masterHost" tf:"master_host,omitempty"`

	// +kubebuilder:validation:Required
	MasterPort *int64 `json:"masterPort" tf:"master_port,omitempty"`
}

type GkeIntegrationGkeAutoscaleDownObservation struct {
}

type GkeIntegrationGkeAutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`
}

type GkeIntegrationGkeAutoscaleHeadroomObservation struct {
}

type GkeIntegrationGkeAutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type GkeIntegrationGkeAutoscaleLabelsObservation struct {
}

type GkeIntegrationGkeAutoscaleLabelsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type GkeIntegrationGkeObservation struct {
}

type GkeIntegrationGkeParameters struct {

	// +kubebuilder:validation:Optional
	AutoUpdate *bool `json:"autoUpdate,omitempty" tf:"auto_update,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *int64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []GkeIntegrationGkeAutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []GkeIntegrationGkeAutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleLabels []GkeIntegrationGkeAutoscaleLabelsParameters `json:"autoscaleLabels,omitempty" tf:"autoscale_labels,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`
}

type GkeLabelsObservation struct {
}

type GkeLabelsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type GkeMetadataObservation struct {
}

type GkeMetadataParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type GkeNetworkInterfaceObservation struct {
}

type GkeNetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	AccessConfigs []NetworkInterfaceAccessConfigsParameters `json:"accessConfigs,omitempty" tf:"access_configs,omitempty"`

	// +kubebuilder:validation:Optional
	AliasIPRanges []NetworkInterfaceAliasIPRangesParameters `json:"aliasIpRanges,omitempty" tf:"alias_ip_ranges,omitempty"`

	// +kubebuilder:validation:Required
	Network *string `json:"network" tf:"network,omitempty"`
}

type GkeObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type GkeParameters struct {

	// +kubebuilder:validation:Optional
	BackendServices []GkeBackendServicesParameters `json:"backendServices,omitempty" tf:"backend_services,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// +kubebuilder:validation:Required
	ClusterZoneName *string `json:"clusterZoneName" tf:"cluster_zone_name,omitempty"`

	// +kubebuilder:validation:Required
	DesiredCapacity *int64 `json:"desiredCapacity" tf:"desired_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Disk []GkeDiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	DrainingTimeout *int64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	Gpu []GkeGpuParameters `json:"gpu,omitempty" tf:"gpu,omitempty"`

	// +kubebuilder:validation:Optional
	IPForwarding *bool `json:"ipForwarding,omitempty" tf:"ip_forwarding,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceTypesCustom []GkeInstanceTypesCustomParameters `json:"instanceTypesCustom,omitempty" tf:"instance_types_custom,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceTypesOndemand *string `json:"instanceTypesOndemand,omitempty" tf:"instance_types_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceTypesPreemptible []*string `json:"instanceTypesPreemptible,omitempty" tf:"instance_types_preemptible,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationDockerSwarm []GkeIntegrationDockerSwarmParameters `json:"integrationDockerSwarm,omitempty" tf:"integration_docker_swarm,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationGke []GkeIntegrationGkeParameters `json:"integrationGke,omitempty" tf:"integration_gke,omitempty"`

	// +kubebuilder:validation:Optional
	Labels []GkeLabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata []GkeMetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	MinSize *int64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterface []GkeNetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	NodeImage *string `json:"nodeImage,omitempty" tf:"node_image,omitempty"`

	// +kubebuilder:validation:Optional
	OndemandCount *int64 `json:"ondemandCount,omitempty" tf:"ondemand_count,omitempty"`

	// +kubebuilder:validation:Optional
	PreemptiblePercentage *int64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	// +kubebuilder:validation:Optional
	ScalingDownPolicy []GkeScalingDownPolicyParameters `json:"scalingDownPolicy,omitempty" tf:"scaling_down_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ScalingUpPolicy []GkeScalingUpPolicyParameters `json:"scalingUpPolicy,omitempty" tf:"scaling_up_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	// +kubebuilder:validation:Optional
	ShutdownScript *string `json:"shutdownScript,omitempty" tf:"shutdown_script,omitempty"`

	// +kubebuilder:validation:Optional
	StartupScript *string `json:"startupScript,omitempty" tf:"startup_script,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type GkeScalingDownPolicyDimensionsObservation struct {
}

type GkeScalingDownPolicyDimensionsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type GkeScalingDownPolicyObservation struct {
}

type GkeScalingDownPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ActionType *string `json:"actionType,omitempty" tf:"action_type,omitempty"`

	// +kubebuilder:validation:Optional
	Adjustment *int64 `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	Cooldown *int64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	Dimensions []GkeScalingDownPolicyDimensionsParameters `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Period *int64 `json:"period,omitempty" tf:"period,omitempty"`

	// +kubebuilder:validation:Required
	PolicyName *string `json:"policyName" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Required
	Threshold *float64 `json:"threshold" tf:"threshold,omitempty"`

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`
}

type GkeScalingUpPolicyDimensionsObservation struct {
}

type GkeScalingUpPolicyDimensionsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type GkeScalingUpPolicyObservation struct {
}

type GkeScalingUpPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ActionType *string `json:"actionType,omitempty" tf:"action_type,omitempty"`

	// +kubebuilder:validation:Optional
	Adjustment *int64 `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	Cooldown *int64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	Dimensions []GkeScalingUpPolicyDimensionsParameters `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Period *int64 `json:"period,omitempty" tf:"period,omitempty"`

	// +kubebuilder:validation:Required
	PolicyName *string `json:"policyName" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Required
	Threshold *float64 `json:"threshold" tf:"threshold,omitempty"`

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`
}

type NetworkInterfaceAccessConfigsObservation struct {
}

type NetworkInterfaceAccessConfigsParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type NetworkInterfaceAliasIPRangesObservation struct {
}

type NetworkInterfaceAliasIPRangesParameters struct {

	// +kubebuilder:validation:Required
	IPCidrRange *string `json:"ipCidrRange" tf:"ip_cidr_range,omitempty"`

	// +kubebuilder:validation:Required
	SubnetworkRangeName *string `json:"subnetworkRangeName" tf:"subnetwork_range_name,omitempty"`
}

// GkeSpec defines the desired state of Gke
type GkeSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     GkeParameters `json:"forProvider"`
}

// GkeStatus defines the observed state of Gke.
type GkeStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        GkeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Gke is the Schema for the Gkes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type Gke struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GkeSpec   `json:"spec"`
	Status            GkeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GkeList contains a list of Gkes
type GkeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Gke `json:"items"`
}

// Repository type metadata.
var (
	Gke_Kind             = "Gke"
	Gke_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Gke_Kind}.String()
	Gke_KindAPIVersion   = Gke_Kind + "." + CRDGroupVersion.String()
	Gke_GroupVersionKind = CRDGroupVersion.WithKind(Gke_Kind)
)

func init() {
	SchemeBuilder.Register(&Gke{}, &GkeList{})
}
