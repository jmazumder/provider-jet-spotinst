/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionObservation struct {
}

type ActionParameters struct {

	// +kubebuilder:validation:Optional
	Adjustment *string `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTargetCapacity *string `json:"maxTargetCapacity,omitempty" tf:"max_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Maximum *string `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// +kubebuilder:validation:Optional
	MinTargetCapacity *string `json:"minTargetCapacity,omitempty" tf:"min_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Minimum *string `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type AutoscaleAttributesObservation struct {
}

type AutoscaleAttributesParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AutoscaleConstraintsObservation struct {
}

type AutoscaleConstraintsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AutoscaleDownObservation struct {
}

type AutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleHeadroomObservation struct {
}

type AutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleLabelsObservation struct {
}

type AutoscaleLabelsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AwsObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AwsParameters struct {

	// +kubebuilder:validation:Optional
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// +kubebuilder:validation:Optional
	BlockDevicesMode *string `json:"blockDevicesMode,omitempty" tf:"block_devices_mode,omitempty"`

	// +kubebuilder:validation:Optional
	CPUCredits *string `json:"cpuCredits,omitempty" tf:"cpu_credits,omitempty"`

	// +kubebuilder:validation:Optional
	CPUOptions []CPUOptionsParameters `json:"cpuOptions,omitempty" tf:"cpu_options,omitempty"`

	// +kubebuilder:validation:Optional
	CapacityUnit *string `json:"capacityUnit,omitempty" tf:"capacity_unit,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredCapacity *int64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	DrainingTimeout *int64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	EBSBlockDevice []EBSBlockDeviceParameters `json:"ebsBlockDevice,omitempty" tf:"ebs_block_device,omitempty"`

	// +kubebuilder:validation:Optional
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// +kubebuilder:validation:Optional
	ElasticIps []*string `json:"elasticIps,omitempty" tf:"elastic_ips,omitempty"`

	// +kubebuilder:validation:Optional
	ElasticLoadBalancers []*string `json:"elasticLoadBalancers,omitempty" tf:"elastic_load_balancers,omitempty"`

	// +kubebuilder:validation:Optional
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" tf:"enable_monitoring,omitempty"`

	// +kubebuilder:validation:Optional
	EphemeralBlockDevice []EphemeralBlockDeviceParameters `json:"ephemeralBlockDevice,omitempty" tf:"ephemeral_block_device,omitempty"`

	// +kubebuilder:validation:Required
	FallbackToOndemand *bool `json:"fallbackToOndemand" tf:"fallback_to_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckGracePeriod *int64 `json:"healthCheckGracePeriod,omitempty" tf:"health_check_grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckUnhealthyDurationBeforeReplacement *int64 `json:"healthCheckUnhealthyDurationBeforeReplacement,omitempty" tf:"health_check_unhealthy_duration_before_replacement,omitempty"`

	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Required
	InstanceTypesOndemand *string `json:"instanceTypesOndemand" tf:"instance_types_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceTypesPreferredSpot []*string `json:"instanceTypesPreferredSpot,omitempty" tf:"instance_types_preferred_spot,omitempty"`

	// +kubebuilder:validation:Required
	InstanceTypesSpot []*string `json:"instanceTypesSpot" tf:"instance_types_spot,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceTypesWeights []InstanceTypesWeightsParameters `json:"instanceTypesWeights,omitempty" tf:"instance_types_weights,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationBeanstalk []IntegrationBeanstalkParameters `json:"integrationBeanstalk,omitempty" tf:"integration_beanstalk,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationCodedeploy []IntegrationCodedeployParameters `json:"integrationCodedeploy,omitempty" tf:"integration_codedeploy,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationDockerSwarm []IntegrationDockerSwarmParameters `json:"integrationDockerSwarm,omitempty" tf:"integration_docker_swarm,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationEcs []IntegrationEcsParameters `json:"integrationEcs,omitempty" tf:"integration_ecs,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationGitlab []IntegrationGitlabParameters `json:"integrationGitlab,omitempty" tf:"integration_gitlab,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationKubernetes []IntegrationKubernetesParameters `json:"integrationKubernetes,omitempty" tf:"integration_kubernetes,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationMesosphere []IntegrationMesosphereParameters `json:"integrationMesosphere,omitempty" tf:"integration_mesosphere,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationMultaiRuntime []IntegrationMultaiRuntimeParameters `json:"integrationMultaiRuntime,omitempty" tf:"integration_multai_runtime,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationNomad []IntegrationNomadParameters `json:"integrationNomad,omitempty" tf:"integration_nomad,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationRancher []IntegrationRancherParameters `json:"integrationRancher,omitempty" tf:"integration_rancher,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationRoute53 []IntegrationRoute53Parameters `json:"integrationRoute53,omitempty" tf:"integration_route53,omitempty"`

	// +kubebuilder:validation:Optional
	Itf []ItfParameters `json:"itf,omitempty" tf:"itf,omitempty"`

	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// +kubebuilder:validation:Optional
	LifetimePeriod *string `json:"lifetimePeriod,omitempty" tf:"lifetime_period,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	MetadataOptions []MetadataOptionsParameters `json:"metadataOptions,omitempty" tf:"metadata_options,omitempty"`

	// +kubebuilder:validation:Optional
	MinSize *int64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// +kubebuilder:validation:Optional
	MinimumInstanceLifetime *int64 `json:"minimumInstanceLifetime,omitempty" tf:"minimum_instance_lifetime,omitempty"`

	// +kubebuilder:validation:Optional
	MultaiTargetSets []MultaiTargetSetsParameters `json:"multaiTargetSets,omitempty" tf:"multai_target_sets,omitempty"`

	// +kubebuilder:validation:Optional
	MultipleMetrics []MultipleMetricsParameters `json:"multipleMetrics,omitempty" tf:"multiple_metrics,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	OndemandCount *int64 `json:"ondemandCount,omitempty" tf:"ondemand_count,omitempty"`

	// +kubebuilder:validation:Required
	Orientation *string `json:"orientation" tf:"orientation,omitempty"`

	// +kubebuilder:validation:Optional
	PersistBlockDevices *bool `json:"persistBlockDevices,omitempty" tf:"persist_block_devices,omitempty"`

	// +kubebuilder:validation:Optional
	PersistPrivateIP *bool `json:"persistPrivateIp,omitempty" tf:"persist_private_ip,omitempty"`

	// +kubebuilder:validation:Optional
	PersistRootDevice *bool `json:"persistRootDevice,omitempty" tf:"persist_root_device,omitempty"`

	// +kubebuilder:validation:Optional
	PlacementTenancy *string `json:"placementTenancy,omitempty" tf:"placement_tenancy,omitempty"`

	// +kubebuilder:validation:Optional
	PreferredAvailabilityZones []*string `json:"preferredAvailabilityZones,omitempty" tf:"preferred_availability_zones,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIps []*string `json:"privateIps,omitempty" tf:"private_ips,omitempty"`

	// +kubebuilder:validation:Required
	Product *string `json:"product" tf:"product,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceTagSpecification []ResourceTagSpecificationParameters `json:"resourceTagSpecification,omitempty" tf:"resource_tag_specification,omitempty"`

	// +kubebuilder:validation:Optional
	RevertToSpot []RevertToSpotParameters `json:"revertToSpot,omitempty" tf:"revert_to_spot,omitempty"`

	// +kubebuilder:validation:Optional
	ScalingDownPolicy []ScalingDownPolicyParameters `json:"scalingDownPolicy,omitempty" tf:"scaling_down_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ScalingStrategy []ScalingStrategyParameters `json:"scalingStrategy,omitempty" tf:"scaling_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	ScalingTargetPolicy []ScalingTargetPolicyParameters `json:"scalingTargetPolicy,omitempty" tf:"scaling_target_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ScalingUpPolicy []ScalingUpPolicyParameters `json:"scalingUpPolicy,omitempty" tf:"scaling_up_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduledTask []ScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// +kubebuilder:validation:Required
	SecurityGroups []*string `json:"securityGroups" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	ShutdownScript *string `json:"shutdownScript,omitempty" tf:"shutdown_script,omitempty"`

	// +kubebuilder:validation:Optional
	Signal []SignalParameters `json:"signal,omitempty" tf:"signal,omitempty"`

	// +kubebuilder:validation:Optional
	SpotPercentage *int64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	StatefulDeallocation []StatefulDeallocationParameters `json:"statefulDeallocation,omitempty" tf:"stateful_deallocation,omitempty"`

	// +kubebuilder:validation:Optional
	StatefulInstanceAction []StatefulInstanceActionParameters `json:"statefulInstanceAction,omitempty" tf:"stateful_instance_action,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []AwsTagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupArns []*string `json:"targetGroupArns,omitempty" tf:"target_group_arns,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForCapacity *int64 `json:"waitForCapacity,omitempty" tf:"wait_for_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForCapacityTimeout *int64 `json:"waitForCapacityTimeout,omitempty" tf:"wait_for_capacity_timeout,omitempty"`
}

type AwsTagsObservation struct {
}

type AwsTagsParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type BatchObservation struct {
}

type BatchParameters struct {

	// +kubebuilder:validation:Required
	JobQueueNames []*string `json:"jobQueueNames" tf:"job_queue_names,omitempty"`
}

type CPUOptionsObservation struct {
}

type CPUOptionsParameters struct {

	// +kubebuilder:validation:Required
	ThreadsPerCore *int64 `json:"threadsPerCore" tf:"threads_per_core,omitempty"`
}

type DefaultStaticTargetGroupObservation struct {
}

type DefaultStaticTargetGroupParameters struct {

	// +kubebuilder:validation:Required
	Arn *string `json:"arn" tf:"arn,omitempty"`

	// +kubebuilder:validation:Required
	Percentage *float64 `json:"percentage" tf:"percentage,omitempty"`
}

type DeploymentGroupsObservation struct {
}

type DeploymentGroupsParameters struct {

	// +kubebuilder:validation:Required
	ApplicationName *string `json:"applicationName" tf:"application_name,omitempty"`

	// +kubebuilder:validation:Required
	DeploymentGroupName *string `json:"deploymentGroupName" tf:"deployment_group_name,omitempty"`
}

type DeploymentPreferencesObservation struct {
}

type DeploymentPreferencesParameters struct {

	// +kubebuilder:validation:Optional
	AutomaticRoll *bool `json:"automaticRoll,omitempty" tf:"automatic_roll,omitempty"`

	// +kubebuilder:validation:Optional
	BatchSizePercentage *int64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *int64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy []StrategyParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type DimensionsObservation struct {
}

type DimensionsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type DomainsObservation struct {
}

type DomainsParameters struct {

	// +kubebuilder:validation:Required
	HostedZoneID *string `json:"hostedZoneId" tf:"hosted_zone_id,omitempty"`

	// +kubebuilder:validation:Optional
	RecordSetType *string `json:"recordSetType,omitempty" tf:"record_set_type,omitempty"`

	// +kubebuilder:validation:Required
	RecordSets []RecordSetsParameters `json:"recordSets" tf:"record_sets,omitempty"`

	// +kubebuilder:validation:Optional
	SpotinstAcctID *string `json:"spotinstAcctId,omitempty" tf:"spotinst_acct_id,omitempty"`
}

type EBSBlockDeviceObservation struct {
}

type EBSBlockDeviceParameters struct {

	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Required
	DeviceName *string `json:"deviceName" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// +kubebuilder:validation:Optional
	Iops *int64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// +kubebuilder:validation:Optional
	Throughput *int64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *int64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type EphemeralBlockDeviceObservation struct {
}

type EphemeralBlockDeviceParameters struct {

	// +kubebuilder:validation:Required
	DeviceName *string `json:"deviceName" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Required
	VirtualName *string `json:"virtualName" tf:"virtual_name,omitempty"`
}

type ExpressionsObservation struct {
}

type ExpressionsParameters struct {

	// +kubebuilder:validation:Required
	Expression *string `json:"expression" tf:"expression,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type InstanceTypesWeightsObservation struct {
}

type InstanceTypesWeightsParameters struct {

	// +kubebuilder:validation:Required
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`

	// +kubebuilder:validation:Required
	Weight *int64 `json:"weight" tf:"weight,omitempty"`
}

type IntegrationBeanstalkObservation struct {
}

type IntegrationBeanstalkParameters struct {

	// +kubebuilder:validation:Optional
	DeploymentPreferences []DeploymentPreferencesParameters `json:"deploymentPreferences,omitempty" tf:"deployment_preferences,omitempty"`

	// +kubebuilder:validation:Optional
	EnvironmentID *string `json:"environmentId,omitempty" tf:"environment_id,omitempty"`

	// +kubebuilder:validation:Optional
	ManagedActions []ManagedActionsParameters `json:"managedActions,omitempty" tf:"managed_actions,omitempty"`
}

type IntegrationCodedeployObservation struct {
}

type IntegrationCodedeployParameters struct {

	// +kubebuilder:validation:Required
	CleanupOnFailure *bool `json:"cleanupOnFailure" tf:"cleanup_on_failure,omitempty"`

	// +kubebuilder:validation:Required
	DeploymentGroups []DeploymentGroupsParameters `json:"deploymentGroups" tf:"deployment_groups,omitempty"`

	// +kubebuilder:validation:Required
	TerminateInstanceOnFailure *bool `json:"terminateInstanceOnFailure" tf:"terminate_instance_on_failure,omitempty"`
}

type IntegrationDockerSwarmObservation struct {
}

type IntegrationDockerSwarmParameters struct {

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *int64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []AutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []AutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	MasterHost *string `json:"masterHost" tf:"master_host,omitempty"`

	// +kubebuilder:validation:Required
	MasterPort *int64 `json:"masterPort" tf:"master_port,omitempty"`
}

type IntegrationEcsAutoscaleDownObservation struct {
}

type IntegrationEcsAutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type IntegrationEcsAutoscaleHeadroomObservation struct {
}

type IntegrationEcsAutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type IntegrationEcsObservation struct {
}

type IntegrationEcsParameters struct {

	// +kubebuilder:validation:Optional
	AutoscaleAttributes []AutoscaleAttributesParameters `json:"autoscaleAttributes,omitempty" tf:"autoscale_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *int64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []IntegrationEcsAutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []IntegrationEcsAutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleScaleDownNonServiceTasks *bool `json:"autoscaleScaleDownNonServiceTasks,omitempty" tf:"autoscale_scale_down_non_service_tasks,omitempty"`

	// +kubebuilder:validation:Optional
	Batch []BatchParameters `json:"batch,omitempty" tf:"batch,omitempty"`

	// +kubebuilder:validation:Required
	ClusterName *string `json:"clusterName" tf:"cluster_name,omitempty"`
}

type IntegrationGitlabObservation struct {
}

type IntegrationGitlabParameters struct {

	// +kubebuilder:validation:Optional
	Runner []RunnerParameters `json:"runner,omitempty" tf:"runner,omitempty"`
}

type IntegrationKubernetesAutoscaleDownObservation struct {
}

type IntegrationKubernetesAutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`
}

type IntegrationKubernetesAutoscaleHeadroomObservation struct {
}

type IntegrationKubernetesAutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type IntegrationKubernetesObservation struct {
}

type IntegrationKubernetesParameters struct {

	// +kubebuilder:validation:Optional
	APIServer *string `json:"apiServer,omitempty" tf:"api_server,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *int64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []IntegrationKubernetesAutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []IntegrationKubernetesAutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleLabels []AutoscaleLabelsParameters `json:"autoscaleLabels,omitempty" tf:"autoscale_labels,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterIdentifier *string `json:"clusterIdentifier,omitempty" tf:"cluster_identifier,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationMode *string `json:"integrationMode,omitempty" tf:"integration_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Token *string `json:"token,omitempty" tf:"token,omitempty"`
}

type IntegrationMesosphereObservation struct {
}

type IntegrationMesosphereParameters struct {

	// +kubebuilder:validation:Required
	APIServer *string `json:"apiServer" tf:"api_server,omitempty"`
}

type IntegrationMultaiRuntimeObservation struct {
}

type IntegrationMultaiRuntimeParameters struct {

	// +kubebuilder:validation:Required
	DeploymentID *string `json:"deploymentId" tf:"deployment_id,omitempty"`
}

type IntegrationNomadAutoscaleDownObservation struct {
}

type IntegrationNomadAutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`
}

type IntegrationNomadAutoscaleHeadroomObservation struct {
}

type IntegrationNomadAutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type IntegrationNomadObservation struct {
}

type IntegrationNomadParameters struct {

	// +kubebuilder:validation:Optional
	ACLToken *string `json:"aclToken,omitempty" tf:"acl_token,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleConstraints []AutoscaleConstraintsParameters `json:"autoscaleConstraints,omitempty" tf:"autoscale_constraints,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *int64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []IntegrationNomadAutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []IntegrationNomadAutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	MasterHost *string `json:"masterHost" tf:"master_host,omitempty"`

	// +kubebuilder:validation:Required
	MasterPort *int64 `json:"masterPort" tf:"master_port,omitempty"`
}

type IntegrationRancherObservation struct {
}

type IntegrationRancherParameters struct {

	// +kubebuilder:validation:Required
	AccessKey *string `json:"accessKey" tf:"access_key,omitempty"`

	// +kubebuilder:validation:Required
	MasterHost *string `json:"masterHost" tf:"master_host,omitempty"`

	// +kubebuilder:validation:Required
	SecretKey *string `json:"secretKey" tf:"secret_key,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type IntegrationRoute53Observation struct {
}

type IntegrationRoute53Parameters struct {

	// +kubebuilder:validation:Required
	Domains []DomainsParameters `json:"domains" tf:"domains,omitempty"`
}

type ItfObservation struct {
}

type ItfParameters struct {

	// +kubebuilder:validation:Optional
	DefaultStaticTargetGroup []DefaultStaticTargetGroupParameters `json:"defaultStaticTargetGroup,omitempty" tf:"default_static_target_group,omitempty"`

	// +kubebuilder:validation:Required
	FixedTargetGroups *bool `json:"fixedTargetGroups" tf:"fixed_target_groups,omitempty"`

	// +kubebuilder:validation:Required
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	MigrationHealthinessThreshold *int64 `json:"migrationHealthinessThreshold,omitempty" tf:"migration_healthiness_threshold,omitempty"`

	// +kubebuilder:validation:Required
	TargetGroupConfig []TargetGroupConfigParameters `json:"targetGroupConfig" tf:"target_group_config,omitempty"`

	// +kubebuilder:validation:Required
	WeightStrategy *string `json:"weightStrategy" tf:"weight_strategy,omitempty"`
}

type ListenerRuleObservation struct {
}

type ListenerRuleParameters struct {

	// +kubebuilder:validation:Required
	RuleArn *string `json:"ruleArn" tf:"rule_arn,omitempty"`

	// +kubebuilder:validation:Optional
	StaticTargetGroup []StaticTargetGroupParameters `json:"staticTargetGroup,omitempty" tf:"static_target_group,omitempty"`
}

type LoadBalancerObservation struct {
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Required
	ListenerRule []ListenerRuleParameters `json:"listenerRule" tf:"listener_rule,omitempty"`

	// +kubebuilder:validation:Required
	LoadBalancerArn *string `json:"loadBalancerArn" tf:"load_balancer_arn,omitempty"`
}

type ManagedActionsObservation struct {
}

type ManagedActionsParameters struct {

	// +kubebuilder:validation:Optional
	PlatformUpdate []PlatformUpdateParameters `json:"platformUpdate,omitempty" tf:"platform_update,omitempty"`
}

type MatcherObservation struct {
}

type MatcherParameters struct {

	// +kubebuilder:validation:Optional
	GRPCCode *string `json:"grpcCode,omitempty" tf:"grpc_code,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPCode *string `json:"httpCode,omitempty" tf:"http_code,omitempty"`
}

type MetadataOptionsObservation struct {
}

type MetadataOptionsParameters struct {

	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// +kubebuilder:validation:Required
	HTTPTokens *string `json:"httpTokens" tf:"http_tokens,omitempty"`
}

type MetricsObservation struct {
}

type MetricsParameters struct {

	// +kubebuilder:validation:Optional
	Dimensions []DimensionsParameters `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendedStatistic *string `json:"extendedStatistic,omitempty" tf:"extended_statistic,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Optional
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type MultaiTargetSetsObservation struct {
}

type MultaiTargetSetsParameters struct {

	// +kubebuilder:validation:Required
	BalancerID *string `json:"balancerId" tf:"balancer_id,omitempty"`

	// +kubebuilder:validation:Required
	TargetSetID *string `json:"targetSetId" tf:"target_set_id,omitempty"`
}

type MultipleMetricsObservation struct {
}

type MultipleMetricsParameters struct {

	// +kubebuilder:validation:Optional
	Expressions []ExpressionsParameters `json:"expressions,omitempty" tf:"expressions,omitempty"`

	// +kubebuilder:validation:Optional
	Metrics []MetricsParameters `json:"metrics,omitempty" tf:"metrics,omitempty"`
}

type NetworkInterfaceObservation struct {
}

type NetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	DeviceIndex *string `json:"deviceIndex" tf:"device_index,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty" tf:"network_interface_id,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" tf:"private_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	SecondaryPrivateIPAddressCount *string `json:"secondaryPrivateIpAddressCount,omitempty" tf:"secondary_private_ip_address_count,omitempty"`
}

type OnFailureObservation struct {
}

type OnFailureParameters struct {

	// +kubebuilder:validation:Required
	ActionType *string `json:"actionType" tf:"action_type,omitempty"`

	// +kubebuilder:validation:Optional
	BatchNum *int64 `json:"batchNum,omitempty" tf:"batch_num,omitempty"`

	// +kubebuilder:validation:Optional
	DrainingTimeout *int64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldDecrementTargetCapacity *bool `json:"shouldDecrementTargetCapacity,omitempty" tf:"should_decrement_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldHandleAllBatches *bool `json:"shouldHandleAllBatches,omitempty" tf:"should_handle_all_batches,omitempty"`
}

type PlatformUpdateObservation struct {
}

type PlatformUpdateParameters struct {

	// +kubebuilder:validation:Optional
	PerformAt *string `json:"performAt,omitempty" tf:"perform_at,omitempty"`

	// +kubebuilder:validation:Optional
	TimeWindow *string `json:"timeWindow,omitempty" tf:"time_window,omitempty"`

	// +kubebuilder:validation:Optional
	UpdateLevel *string `json:"updateLevel,omitempty" tf:"update_level,omitempty"`
}

type RecordSetsObservation struct {
}

type RecordSetsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	UsePublicDNS *bool `json:"usePublicDns,omitempty" tf:"use_public_dns,omitempty"`

	// +kubebuilder:validation:Optional
	UsePublicIP *bool `json:"usePublicIp,omitempty" tf:"use_public_ip,omitempty"`
}

type ResourceTagSpecificationObservation struct {
}

type ResourceTagSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	ShouldTagAmis *bool `json:"shouldTagAmis,omitempty" tf:"should_tag_amis,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldTagEnis *bool `json:"shouldTagEnis,omitempty" tf:"should_tag_enis,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldTagSnapshots *bool `json:"shouldTagSnapshots,omitempty" tf:"should_tag_snapshots,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldTagVolumes *bool `json:"shouldTagVolumes,omitempty" tf:"should_tag_volumes,omitempty"`
}

type RevertToSpotObservation struct {
}

type RevertToSpotParameters struct {

	// +kubebuilder:validation:Required
	PerformAt *string `json:"performAt" tf:"perform_at,omitempty"`

	// +kubebuilder:validation:Optional
	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type RollConfigObservation struct {
}

type RollConfigParameters struct {

	// +kubebuilder:validation:Required
	BatchSizePercentage *int64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *int64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy []RollConfigStrategyParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForRollPercentage *float64 `json:"waitForRollPercentage,omitempty" tf:"wait_for_roll_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForRollTimeout *int64 `json:"waitForRollTimeout,omitempty" tf:"wait_for_roll_timeout,omitempty"`
}

type RollConfigStrategyObservation struct {
}

type RollConfigStrategyParameters struct {

	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *int64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	OnFailure []OnFailureParameters `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldDrainInstances *bool `json:"shouldDrainInstances,omitempty" tf:"should_drain_instances,omitempty"`
}

type RunnerObservation struct {
}

type RunnerParameters struct {

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`
}

type ScalingDownPolicyDimensionsObservation struct {
}

type ScalingDownPolicyDimensionsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ScalingDownPolicyObservation struct {
}

type ScalingDownPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ActionType *string `json:"actionType,omitempty" tf:"action_type,omitempty"`

	// +kubebuilder:validation:Optional
	Adjustment *string `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	Cooldown *int64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	Dimensions []ScalingDownPolicyDimensionsParameters `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTargetCapacity *string `json:"maxTargetCapacity,omitempty" tf:"max_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Maximum *string `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Optional
	MinTargetCapacity *string `json:"minTargetCapacity,omitempty" tf:"min_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Minimum *string `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Period *int64 `json:"period,omitempty" tf:"period,omitempty"`

	// +kubebuilder:validation:Required
	PolicyName *string `json:"policyName" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Optional
	StepAdjustments []StepAdjustmentsParameters `json:"stepAdjustments,omitempty" tf:"step_adjustments,omitempty"`

	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`

	// +kubebuilder:validation:Optional
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type ScalingStrategyObservation struct {
}

type ScalingStrategyParameters struct {

	// +kubebuilder:validation:Optional
	TerminateAtEndOfBillingHour *bool `json:"terminateAtEndOfBillingHour,omitempty" tf:"terminate_at_end_of_billing_hour,omitempty"`

	// +kubebuilder:validation:Optional
	TerminationPolicy *string `json:"terminationPolicy,omitempty" tf:"termination_policy,omitempty"`
}

type ScalingTargetPolicyDimensionsObservation struct {
}

type ScalingTargetPolicyDimensionsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ScalingTargetPolicyObservation struct {
}

type ScalingTargetPolicyParameters struct {

	// +kubebuilder:validation:Optional
	Cooldown *int64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	Dimensions []ScalingTargetPolicyDimensionsParameters `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	MaxCapacityPerScale *string `json:"maxCapacityPerScale,omitempty" tf:"max_capacity_per_scale,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Period *int64 `json:"period,omitempty" tf:"period,omitempty"`

	// +kubebuilder:validation:Required
	PolicyName *string `json:"policyName" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	PredictiveMode *string `json:"predictiveMode,omitempty" tf:"predictive_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Required
	Target *float64 `json:"target" tf:"target,omitempty"`

	// +kubebuilder:validation:Optional
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type ScalingUpPolicyDimensionsObservation struct {
}

type ScalingUpPolicyDimensionsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ScalingUpPolicyObservation struct {
}

type ScalingUpPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ActionType *string `json:"actionType,omitempty" tf:"action_type,omitempty"`

	// +kubebuilder:validation:Optional
	Adjustment *string `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	Cooldown *int64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	Dimensions []ScalingUpPolicyDimensionsParameters `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTargetCapacity *string `json:"maxTargetCapacity,omitempty" tf:"max_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Maximum *string `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Optional
	MinTargetCapacity *string `json:"minTargetCapacity,omitempty" tf:"min_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Minimum *string `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Period *int64 `json:"period,omitempty" tf:"period,omitempty"`

	// +kubebuilder:validation:Required
	PolicyName *string `json:"policyName" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Optional
	StepAdjustments []ScalingUpPolicyStepAdjustmentsParameters `json:"stepAdjustments,omitempty" tf:"step_adjustments,omitempty"`

	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`

	// +kubebuilder:validation:Optional
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type ScalingUpPolicyStepAdjustmentsObservation struct {
}

type ScalingUpPolicyStepAdjustmentsParameters struct {

	// +kubebuilder:validation:Required
	Action []StepAdjustmentsActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Threshold *int64 `json:"threshold" tf:"threshold,omitempty"`
}

type ScheduledTaskObservation struct {
}

type ScheduledTaskParameters struct {

	// +kubebuilder:validation:Optional
	Adjustment *string `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	AdjustmentPercentage *string `json:"adjustmentPercentage,omitempty" tf:"adjustment_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	BatchSizePercentage *string `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// +kubebuilder:validation:Optional
	Frequency *string `json:"frequency,omitempty" tf:"frequency,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *string `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MaxCapacity *string `json:"maxCapacity,omitempty" tf:"max_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	MinCapacity *string `json:"minCapacity,omitempty" tf:"min_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleMaxCapacity *string `json:"scaleMaxCapacity,omitempty" tf:"scale_max_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleMinCapacity *string `json:"scaleMinCapacity,omitempty" tf:"scale_min_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleTargetCapacity *string `json:"scaleTargetCapacity,omitempty" tf:"scale_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// +kubebuilder:validation:Optional
	TargetCapacity *string `json:"targetCapacity,omitempty" tf:"target_capacity,omitempty"`

	// +kubebuilder:validation:Required
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type SignalObservation struct {
}

type SignalParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type StatefulDeallocationObservation struct {
}

type StatefulDeallocationParameters struct {

	// +kubebuilder:validation:Optional
	ShouldDeleteImages *bool `json:"shouldDeleteImages,omitempty" tf:"should_delete_images,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldDeleteNetworkInterfaces *bool `json:"shouldDeleteNetworkInterfaces,omitempty" tf:"should_delete_network_interfaces,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldDeleteSnapshots *bool `json:"shouldDeleteSnapshots,omitempty" tf:"should_delete_snapshots,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldDeleteVolumes *bool `json:"shouldDeleteVolumes,omitempty" tf:"should_delete_volumes,omitempty"`
}

type StatefulInstanceActionObservation struct {
}

type StatefulInstanceActionParameters struct {

	// +kubebuilder:validation:Required
	StatefulInstanceID *string `json:"statefulInstanceId" tf:"stateful_instance_id,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type StaticTargetGroupObservation struct {
}

type StaticTargetGroupParameters struct {

	// +kubebuilder:validation:Required
	Arn *string `json:"arn" tf:"arn,omitempty"`

	// +kubebuilder:validation:Required
	Percentage *float64 `json:"percentage" tf:"percentage,omitempty"`
}

type StepAdjustmentsActionObservation struct {
}

type StepAdjustmentsActionParameters struct {

	// +kubebuilder:validation:Optional
	Adjustment *string `json:"adjustment,omitempty" tf:"adjustment,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTargetCapacity *string `json:"maxTargetCapacity,omitempty" tf:"max_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Maximum *string `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// +kubebuilder:validation:Optional
	MinTargetCapacity *string `json:"minTargetCapacity,omitempty" tf:"min_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Minimum *string `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type StepAdjustmentsObservation struct {
}

type StepAdjustmentsParameters struct {

	// +kubebuilder:validation:Required
	Action []ActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Threshold *int64 `json:"threshold" tf:"threshold,omitempty"`
}

type StrategyObservation struct {
}

type StrategyParameters struct {

	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldDrainInstances *bool `json:"shouldDrainInstances,omitempty" tf:"should_drain_instances,omitempty"`
}

type TagsObservation struct {
}

type TagsParameters struct {

	// +kubebuilder:validation:Required
	TagKey *string `json:"tagKey" tf:"tag_key,omitempty"`

	// +kubebuilder:validation:Optional
	TagValue *string `json:"tagValue,omitempty" tf:"tag_value,omitempty"`
}

type TargetGroupConfigObservation struct {
}

type TargetGroupConfigParameters struct {

	// +kubebuilder:validation:Optional
	HealthCheckIntervalSeconds *int64 `json:"healthCheckIntervalSeconds,omitempty" tf:"health_check_interval_seconds,omitempty"`

	// +kubebuilder:validation:Required
	HealthCheckPath *string `json:"healthCheckPath" tf:"health_check_path,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckPort *string `json:"healthCheckPort,omitempty" tf:"health_check_port,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckProtocol *string `json:"healthCheckProtocol,omitempty" tf:"health_check_protocol,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckTimeoutSeconds *int64 `json:"healthCheckTimeoutSeconds,omitempty" tf:"health_check_timeout_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThresholdCount *int64 `json:"healthyThresholdCount,omitempty" tf:"healthy_threshold_count,omitempty"`

	// +kubebuilder:validation:Optional
	Matcher []MatcherParameters `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	ProtocolVersion *string `json:"protocolVersion,omitempty" tf:"protocol_version,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThresholdCount *int64 `json:"unhealthyThresholdCount,omitempty" tf:"unhealthy_threshold_count,omitempty"`

	// +kubebuilder:validation:Required
	VPCID *string `json:"vpcId" tf:"vpc_id,omitempty"`
}

type UpdatePolicyObservation struct {
}

type UpdatePolicyParameters struct {

	// +kubebuilder:validation:Optional
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// +kubebuilder:validation:Required
	ShouldResumeStateful *bool `json:"shouldResumeStateful" tf:"should_resume_stateful,omitempty"`

	// +kubebuilder:validation:Required
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// AwsSpec defines the desired state of Aws
type AwsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AwsParameters `json:"forProvider"`
}

// AwsStatus defines the observed state of Aws.
type AwsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AwsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Aws is the Schema for the Awss API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type Aws struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AwsSpec   `json:"spec"`
	Status            AwsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AwsList contains a list of Awss
type AwsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Aws `json:"items"`
}

// Repository type metadata.
var (
	Aws_Kind             = "Aws"
	Aws_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Aws_Kind}.String()
	Aws_KindAPIVersion   = Aws_Kind + "." + CRDGroupVersion.String()
	Aws_GroupVersionKind = CRDGroupVersion.WithKind(Aws_Kind)
)

func init() {
	SchemeBuilder.Register(&Aws{}, &AwsList{})
}
