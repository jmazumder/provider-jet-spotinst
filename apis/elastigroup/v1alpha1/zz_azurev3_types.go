/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationSecurityGroupObservation struct {
}

type ApplicationSecurityGroupParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`
}

type AzureV3ImageObservation struct {
}

type AzureV3ImageParameters struct {

	// +kubebuilder:validation:Optional
	Custom []ImageCustomParameters `json:"custom,omitempty" tf:"custom,omitempty"`

	// +kubebuilder:validation:Optional
	Marketplace []ImageMarketplaceParameters `json:"marketplace,omitempty" tf:"marketplace,omitempty"`
}

type AzureV3LoginObservation struct {
}

type AzureV3LoginParameters struct {

	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password,omitempty"`

	// +kubebuilder:validation:Optional
	SSHPublicKey *string `json:"sshPublicKey,omitempty" tf:"ssh_public_key,omitempty"`

	// +kubebuilder:validation:Required
	UserName *string `json:"userName" tf:"user_name,omitempty"`
}

type AzureV3NetworkObservation struct {
}

type AzureV3NetworkParameters struct {

	// +kubebuilder:validation:Required
	NetworkInterfaces []NetworkInterfacesParameters `json:"networkInterfaces" tf:"network_interfaces,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Required
	VirtualNetworkName *string `json:"virtualNetworkName" tf:"virtual_network_name,omitempty"`
}

type AzureV3Observation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AzureV3Parameters struct {

	// +kubebuilder:validation:Optional
	CustomData *string `json:"customData,omitempty" tf:"custom_data,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredCapacity *int64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	Image []AzureV3ImageParameters `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	Login []AzureV3LoginParameters `json:"login,omitempty" tf:"login,omitempty"`

	// +kubebuilder:validation:Optional
	ManagedServiceIdentity []ManagedServiceIdentityParameters `json:"managedServiceIdentity,omitempty" tf:"managed_service_identity,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	MinSize *int64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// +kubebuilder:validation:Required
	Network []AzureV3NetworkParameters `json:"network" tf:"network,omitempty"`

	// +kubebuilder:validation:Required
	OdSizes []*string `json:"odSizes" tf:"od_sizes,omitempty"`

	// +kubebuilder:validation:Required
	Os *string `json:"os" tf:"os,omitempty"`

	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Required
	SpotSizes []*string `json:"spotSizes" tf:"spot_sizes,omitempty"`

	// +kubebuilder:validation:Required
	Strategy []AzureV3StrategyParameters `json:"strategy" tf:"strategy,omitempty"`
}

type AzureV3StrategyObservation struct {
}

type AzureV3StrategyParameters struct {

	// +kubebuilder:validation:Optional
	DrainingTimeout *int64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	FallbackToOnDemand *bool `json:"fallbackToOnDemand,omitempty" tf:"fallback_to_on_demand,omitempty"`

	// +kubebuilder:validation:Optional
	OdCount *int64 `json:"odCount,omitempty" tf:"od_count,omitempty"`

	// +kubebuilder:validation:Optional
	SpotPercentage *int64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`
}

type ImageCustomObservation struct {
}

type ImageCustomParameters struct {

	// +kubebuilder:validation:Required
	ImageName *string `json:"imageName" tf:"image_name,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`
}

type ImageMarketplaceObservation struct {
}

type ImageMarketplaceParameters struct {

	// +kubebuilder:validation:Required
	Offer *string `json:"offer" tf:"offer,omitempty"`

	// +kubebuilder:validation:Required
	Publisher *string `json:"publisher" tf:"publisher,omitempty"`

	// +kubebuilder:validation:Required
	Sku *string `json:"sku" tf:"sku,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type ManagedServiceIdentityObservation struct {
}

type ManagedServiceIdentityParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`
}

type NetworkInterfacesAdditionalIPConfigsObservation struct {
}

type NetworkInterfacesAdditionalIPConfigsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIPVersion *string `json:"privateIpVersion,omitempty" tf:"private_ip_version,omitempty"`
}

type NetworkInterfacesObservation struct {
}

type NetworkInterfacesParameters struct {

	// +kubebuilder:validation:Optional
	AdditionalIPConfigs []NetworkInterfacesAdditionalIPConfigsParameters `json:"additionalIpConfigs,omitempty" tf:"additional_ip_configs,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationSecurityGroup []ApplicationSecurityGroupParameters `json:"applicationSecurityGroup,omitempty" tf:"application_security_group,omitempty"`

	// +kubebuilder:validation:Required
	AssignPublicIP *bool `json:"assignPublicIp" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Required
	IsPrimary *bool `json:"isPrimary" tf:"is_primary,omitempty"`

	// +kubebuilder:validation:Required
	SubnetName *string `json:"subnetName" tf:"subnet_name,omitempty"`
}

// AzureV3Spec defines the desired state of AzureV3
type AzureV3Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AzureV3Parameters `json:"forProvider"`
}

// AzureV3Status defines the observed state of AzureV3.
type AzureV3Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AzureV3Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AzureV3 is the Schema for the AzureV3s API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type AzureV3 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AzureV3Spec   `json:"spec"`
	Status            AzureV3Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureV3List contains a list of AzureV3s
type AzureV3List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AzureV3 `json:"items"`
}

// Repository type metadata.
var (
	AzureV3_Kind             = "AzureV3"
	AzureV3_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AzureV3_Kind}.String()
	AzureV3_KindAPIVersion   = AzureV3_Kind + "." + CRDGroupVersion.String()
	AzureV3_GroupVersionKind = CRDGroupVersion.WithKind(AzureV3_Kind)
)

func init() {
	SchemeBuilder.Register(&AzureV3{}, &AzureV3List{})
}
