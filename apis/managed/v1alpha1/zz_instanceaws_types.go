/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BlockDeviceMappingsObservation struct {
}

type BlockDeviceMappingsParameters struct {

	// +kubebuilder:validation:Required
	DeviceName *string `json:"deviceName" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	EBS []EBSParameters `json:"ebs,omitempty" tf:"ebs,omitempty"`
}

type DomainsObservation struct {
}

type DomainsParameters struct {

	// +kubebuilder:validation:Required
	HostedZoneID *string `json:"hostedZoneId" tf:"hosted_zone_id,omitempty"`

	// +kubebuilder:validation:Optional
	RecordSetType *string `json:"recordSetType,omitempty" tf:"record_set_type,omitempty"`

	// +kubebuilder:validation:Required
	RecordSets []RecordSetsParameters `json:"recordSets" tf:"record_sets,omitempty"`

	// +kubebuilder:validation:Optional
	SpotinstAcctID *string `json:"spotinstAcctId,omitempty" tf:"spotinst_acct_id,omitempty"`
}

type EBSObservation struct {
}

type EBSParameters struct {

	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Optional
	Iops *int64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// +kubebuilder:validation:Optional
	Throughput *int64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *int64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type InstanceAwsObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type InstanceAwsParameters struct {

	// +kubebuilder:validation:Optional
	AutoHealing *bool `json:"autoHealing,omitempty" tf:"auto_healing,omitempty"`

	// +kubebuilder:validation:Optional
	BlockDeviceMappings []BlockDeviceMappingsParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	// +kubebuilder:validation:Optional
	BlockDevicesMode *string `json:"blockDevicesMode,omitempty" tf:"block_devices_mode,omitempty"`

	// +kubebuilder:validation:Optional
	CPUCredits *string `json:"cpuCredits,omitempty" tf:"cpu_credits,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DrainingTimeout *int64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// +kubebuilder:validation:Optional
	ElasticIP *string `json:"elasticIp,omitempty" tf:"elastic_ip,omitempty"`

	// +kubebuilder:validation:Optional
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" tf:"enable_monitoring,omitempty"`

	// +kubebuilder:validation:Optional
	FallBackToOd *bool `json:"fallBackToOd,omitempty" tf:"fall_back_to_od,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *int64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// +kubebuilder:validation:Required
	ImageID *string `json:"imageId" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Required
	InstanceTypes []*string `json:"instanceTypes" tf:"instance_types,omitempty"`

	// +kubebuilder:validation:Optional
	IntegrationRoute53 []IntegrationRoute53Parameters `json:"integrationRoute53,omitempty" tf:"integration_route53,omitempty"`

	// +kubebuilder:validation:Optional
	KeyPair *string `json:"keyPair,omitempty" tf:"key_pair,omitempty"`

	// +kubebuilder:validation:Optional
	LifeCycle *string `json:"lifeCycle,omitempty" tf:"life_cycle,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancers []LoadBalancersParameters `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	// +kubebuilder:validation:Optional
	ManagedInstanceAction []ManagedInstanceActionParameters `json:"managedInstanceAction,omitempty" tf:"managed_instance_action,omitempty"`

	// +kubebuilder:validation:Optional
	MinimumInstanceLifetime *int64 `json:"minimumInstanceLifetime,omitempty" tf:"minimum_instance_lifetime,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	OptimizationWindows []*string `json:"optimizationWindows,omitempty" tf:"optimization_windows,omitempty"`

	// +kubebuilder:validation:Optional
	Orientation *string `json:"orientation,omitempty" tf:"orientation,omitempty"`

	// +kubebuilder:validation:Required
	PersistBlockDevices *bool `json:"persistBlockDevices" tf:"persist_block_devices,omitempty"`

	// +kubebuilder:validation:Optional
	PersistPrivateIP *bool `json:"persistPrivateIp,omitempty" tf:"persist_private_ip,omitempty"`

	// +kubebuilder:validation:Optional
	PersistRootDevice *bool `json:"persistRootDevice,omitempty" tf:"persist_root_device,omitempty"`

	// +kubebuilder:validation:Optional
	PlacementTenancy *string `json:"placementTenancy,omitempty" tf:"placement_tenancy,omitempty"`

	// +kubebuilder:validation:Optional
	PreferredType *string `json:"preferredType,omitempty" tf:"preferred_type,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// +kubebuilder:validation:Required
	Product *string `json:"product" tf:"product,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceTagSpecification []ResourceTagSpecificationParameters `json:"resourceTagSpecification,omitempty" tf:"resource_tag_specification,omitempty"`

	// +kubebuilder:validation:Optional
	RevertToSpot []RevertToSpotParameters `json:"revertToSpot,omitempty" tf:"revert_to_spot,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduledTask []ScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	ShutdownScript *string `json:"shutdownScript,omitempty" tf:"shutdown_script,omitempty"`

	// +kubebuilder:validation:Required
	SubnetIds []*string `json:"subnetIds" tf:"subnet_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyDuration *int64 `json:"unhealthyDuration,omitempty" tf:"unhealthy_duration,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// +kubebuilder:validation:Required
	VPCID *string `json:"vpcId" tf:"vpc_id,omitempty"`
}

type IntegrationRoute53Observation struct {
}

type IntegrationRoute53Parameters struct {

	// +kubebuilder:validation:Required
	Domains []DomainsParameters `json:"domains" tf:"domains,omitempty"`
}

type LoadBalancersObservation struct {
}

type LoadBalancersParameters struct {

	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// +kubebuilder:validation:Optional
	AutoWeight *bool `json:"autoWeight,omitempty" tf:"auto_weight,omitempty"`

	// +kubebuilder:validation:Optional
	AzAwareness *bool `json:"azAwareness,omitempty" tf:"az_awareness,omitempty"`

	// +kubebuilder:validation:Optional
	BalancerID *string `json:"balancerId,omitempty" tf:"balancer_id,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	TargetSetID *string `json:"targetSetId,omitempty" tf:"target_set_id,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ManagedInstanceActionObservation struct {
}

type ManagedInstanceActionParameters struct {

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type NetworkInterfaceObservation struct {
}

type NetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// +kubebuilder:validation:Required
	DeviceIndex *string `json:"deviceIndex" tf:"device_index,omitempty"`
}

type RecordSetsObservation struct {
}

type RecordSetsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	UsePublicDNS *bool `json:"usePublicDns,omitempty" tf:"use_public_dns,omitempty"`

	// +kubebuilder:validation:Optional
	UsePublicIP *bool `json:"usePublicIp,omitempty" tf:"use_public_ip,omitempty"`
}

type ResourceTagSpecificationObservation struct {
}

type ResourceTagSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	ShouldTagAmis *bool `json:"shouldTagAmis,omitempty" tf:"should_tag_amis,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldTagEnis *bool `json:"shouldTagEnis,omitempty" tf:"should_tag_enis,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldTagSnapshots *bool `json:"shouldTagSnapshots,omitempty" tf:"should_tag_snapshots,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldTagVolumes *bool `json:"shouldTagVolumes,omitempty" tf:"should_tag_volumes,omitempty"`
}

type RevertToSpotObservation struct {
}

type RevertToSpotParameters struct {

	// +kubebuilder:validation:Required
	PerformAt *string `json:"performAt" tf:"perform_at,omitempty"`
}

type ScheduledTaskObservation struct {
}

type ScheduledTaskParameters struct {

	// +kubebuilder:validation:Optional
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// +kubebuilder:validation:Optional
	Frequency *string `json:"frequency,omitempty" tf:"frequency,omitempty"`

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// +kubebuilder:validation:Required
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type TagsObservation struct {
}

type TagsParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

// InstanceAwsSpec defines the desired state of InstanceAws
type InstanceAwsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceAwsParameters `json:"forProvider"`
}

// InstanceAwsStatus defines the observed state of InstanceAws.
type InstanceAwsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceAwsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceAws is the Schema for the InstanceAwss API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type InstanceAws struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              InstanceAwsSpec   `json:"spec"`
	Status            InstanceAwsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceAwsList contains a list of InstanceAwss
type InstanceAwsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []InstanceAws `json:"items"`
}

// Repository type metadata.
var (
	InstanceAws_Kind             = "InstanceAws"
	InstanceAws_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: InstanceAws_Kind}.String()
	InstanceAws_KindAPIVersion   = InstanceAws_Kind + "." + CRDGroupVersion.String()
	InstanceAws_GroupVersionKind = CRDGroupVersion.WithKind(InstanceAws_Kind)
)

func init() {
	SchemeBuilder.Register(&InstanceAws{}, &InstanceAwsList{})
}
