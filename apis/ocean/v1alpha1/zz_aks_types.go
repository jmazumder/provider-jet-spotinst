/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdditionalIPConfigObservation struct {
}

type AdditionalIPConfigParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIPVersion *string `json:"privateIpVersion,omitempty" tf:"private_ip_version,omitempty"`
}

type AksObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AksParameters struct {

	// +kubebuilder:validation:Required
	AcdIdentifier *string `json:"acdIdentifier" tf:"acd_identifier,omitempty"`

	// +kubebuilder:validation:Required
	AksName *string `json:"aksName" tf:"aks_name,omitempty"`

	// +kubebuilder:validation:Required
	AksResourceGroupName *string `json:"aksResourceGroupName" tf:"aks_resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	Autoscaler []AutoscalerParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// +kubebuilder:validation:Optional
	ControllerClusterID *string `json:"controllerClusterId,omitempty" tf:"controller_cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	CustomData *string `json:"customData,omitempty" tf:"custom_data,omitempty"`

	// +kubebuilder:validation:Optional
	Extension []ExtensionParameters `json:"extension,omitempty" tf:"extension,omitempty"`

	// +kubebuilder:validation:Optional
	Health []HealthParameters `json:"health,omitempty" tf:"health,omitempty"`

	// +kubebuilder:validation:Optional
	Image []ImageParameters `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	ManagedServiceIdentity []ManagedServiceIdentityParameters `json:"managedServiceIdentity,omitempty" tf:"managed_service_identity,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Optional
	OsDisk []OsDiskParameters `json:"osDisk,omitempty" tf:"os_disk,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Required
	SSHPublicKey *string `json:"sshPublicKey" tf:"ssh_public_key,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy []StrategyParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`

	// +kubebuilder:validation:Optional
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`

	// +kubebuilder:validation:Optional
	VMSizes []VMSizesParameters `json:"vmSizes,omitempty" tf:"vm_sizes,omitempty"`
}

type AutomaticObservation struct {
}

type AutomaticParameters struct {

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Percentage *int64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type AutoscaleDownObservation struct {
}

type AutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleHeadroomObservation struct {
}

type AutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	Automatic []AutomaticParameters `json:"automatic,omitempty" tf:"automatic,omitempty"`
}

type AutoscalerObservation struct {
}

type AutoscalerParameters struct {

	// +kubebuilder:validation:Optional
	AutoscaleDown []AutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []AutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceLimits []ResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type ExtensionObservation struct {
}

type ExtensionParameters struct {

	// +kubebuilder:validation:Optional
	APIVersion *string `json:"apiVersion,omitempty" tf:"api_version,omitempty"`

	// +kubebuilder:validation:Optional
	MinorVersionAutoUpgrade *bool `json:"minorVersionAutoUpgrade,omitempty" tf:"minor_version_auto_upgrade,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Publisher *string `json:"publisher,omitempty" tf:"publisher,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type HealthObservation struct {
}

type HealthParameters struct {

	// +kubebuilder:validation:Optional
	GracePeriod *int64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`
}

type ImageObservation struct {
}

type ImageParameters struct {

	// +kubebuilder:validation:Optional
	Marketplace []MarketplaceParameters `json:"marketplace,omitempty" tf:"marketplace,omitempty"`
}

type LoadBalancerObservation struct {
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	BackendPoolNames []*string `json:"backendPoolNames,omitempty" tf:"backend_pool_names,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ManagedServiceIdentityObservation struct {
}

type ManagedServiceIdentityParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`
}

type MarketplaceObservation struct {
}

type MarketplaceParameters struct {

	// +kubebuilder:validation:Optional
	Offer *string `json:"offer,omitempty" tf:"offer,omitempty"`

	// +kubebuilder:validation:Optional
	Publisher *string `json:"publisher,omitempty" tf:"publisher,omitempty"`

	// +kubebuilder:validation:Optional
	Sku *string `json:"sku,omitempty" tf:"sku,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NetworkInterfaceObservation struct {
}

type NetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	AdditionalIPConfig []AdditionalIPConfigParameters `json:"additionalIpConfig,omitempty" tf:"additional_ip_config,omitempty"`

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	IsPrimary *bool `json:"isPrimary,omitempty" tf:"is_primary,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroup []SecurityGroupParameters `json:"securityGroup,omitempty" tf:"security_group,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`
}

type NetworkObservation struct {
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	VirtualNetworkName *string `json:"virtualNetworkName,omitempty" tf:"virtual_network_name,omitempty"`
}

type OsDiskObservation struct {
}

type OsDiskParameters struct {

	// +kubebuilder:validation:Required
	SizeGb *int64 `json:"sizeGb" tf:"size_gb,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ResourceLimitsObservation struct {
}

type ResourceLimitsParameters struct {

	// +kubebuilder:validation:Optional
	MaxMemoryGib *int64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// +kubebuilder:validation:Optional
	MaxVcpu *int64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type SecurityGroupObservation struct {
}

type SecurityGroupParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`
}

type StrategyObservation struct {
}

type StrategyParameters struct {

	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	SpotPercentage *int64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`
}

type TagObservation struct {
}

type TagParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type VMSizesObservation struct {
}

type VMSizesParameters struct {

	// +kubebuilder:validation:Optional
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

// AksSpec defines the desired state of Aks
type AksSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AksParameters `json:"forProvider"`
}

// AksStatus defines the observed state of Aks.
type AksStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AksObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Aks is the Schema for the Akss API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type Aks struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AksSpec   `json:"spec"`
	Status            AksStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AksList contains a list of Akss
type AksList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Aks `json:"items"`
}

// Repository type metadata.
var (
	Aks_Kind             = "Aks"
	Aks_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Aks_Kind}.String()
	Aks_KindAPIVersion   = Aks_Kind + "." + CRDGroupVersion.String()
	Aks_GroupVersionKind = CRDGroupVersion.WithKind(Aks_Kind)
)

func init() {
	SchemeBuilder.Register(&Aks{}, &AksList{})
}
