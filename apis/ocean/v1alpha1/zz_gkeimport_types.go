/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoscalerDownObservation struct {
}

type AutoscalerDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscalerHeadroomObservation struct {
}

type AutoscalerHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	GpuPerUnit *int64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type BackendServicesObservation struct {
}

type BackendServicesParameters struct {

	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// +kubebuilder:validation:Optional
	NamedPorts []NamedPortsParameters `json:"namedPorts,omitempty" tf:"named_ports,omitempty"`

	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`

	// +kubebuilder:validation:Required
	ServiceName *string `json:"serviceName" tf:"service_name,omitempty"`
}

type GkeImportAutoscalerObservation struct {
}

type GkeImportAutoscalerParameters struct {

	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *int64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Cooldown *int64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	Down []AutoscalerDownParameters `json:"down,omitempty" tf:"down,omitempty"`

	// +kubebuilder:validation:Optional
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	Headroom []AutoscalerHeadroomParameters `json:"headroom,omitempty" tf:"headroom,omitempty"`

	// +kubebuilder:validation:Optional
	IsAutoConfig *bool `json:"isAutoConfig,omitempty" tf:"is_auto_config,omitempty"`

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceLimits []GkeImportAutoscalerResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type GkeImportAutoscalerResourceLimitsObservation struct {
}

type GkeImportAutoscalerResourceLimitsParameters struct {

	// +kubebuilder:validation:Optional
	MaxMemoryGib *int64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// +kubebuilder:validation:Optional
	MaxVcpu *int64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type GkeImportObservation struct {
	ClusterControllerID *string `json:"clusterControllerId,omitempty" tf:"cluster_controller_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type GkeImportParameters struct {

	// +kubebuilder:validation:Optional
	Autoscaler []GkeImportAutoscalerParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// +kubebuilder:validation:Optional
	BackendServices []BackendServicesParameters `json:"backendServices,omitempty" tf:"backend_services,omitempty"`

	// +kubebuilder:validation:Required
	ClusterName *string `json:"clusterName" tf:"cluster_name,omitempty"`

	// +kubebuilder:validation:Optional
	ControllerClusterID *string `json:"controllerClusterId,omitempty" tf:"controller_cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredCapacity *int64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	MinSize *int64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// +kubebuilder:validation:Optional
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduledTask []GkeImportScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []GkeImportUpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type GkeImportScheduledTaskObservation struct {
}

type GkeImportScheduledTaskParameters struct {

	// +kubebuilder:validation:Optional
	ShutdownHours []GkeImportScheduledTaskShutdownHoursParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Tasks []GkeImportScheduledTaskTasksParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type GkeImportScheduledTaskShutdownHoursObservation struct {
}

type GkeImportScheduledTaskShutdownHoursParameters struct {

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	TimeWindows []*string `json:"timeWindows" tf:"time_windows,omitempty"`
}

type GkeImportScheduledTaskTasksObservation struct {
}

type GkeImportScheduledTaskTasksParameters struct {

	// +kubebuilder:validation:Optional
	BatchSizePercentage *int64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Required
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// +kubebuilder:validation:Required
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type GkeImportUpdatePolicyObservation struct {
}

type GkeImportUpdatePolicyParameters struct {

	// +kubebuilder:validation:Optional
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// +kubebuilder:validation:Optional
	RollConfig []GkeImportUpdatePolicyRollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// +kubebuilder:validation:Required
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

type GkeImportUpdatePolicyRollConfigObservation struct {
}

type GkeImportUpdatePolicyRollConfigParameters struct {

	// +kubebuilder:validation:Required
	BatchSizePercentage *int64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`
}

type NamedPortsObservation struct {
}

type NamedPortsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Ports []*string `json:"ports" tf:"ports,omitempty"`
}

// GkeImportSpec defines the desired state of GkeImport
type GkeImportSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     GkeImportParameters `json:"forProvider"`
}

// GkeImportStatus defines the observed state of GkeImport.
type GkeImportStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        GkeImportObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// GkeImport is the Schema for the GkeImports API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type GkeImport struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GkeImportSpec   `json:"spec"`
	Status            GkeImportStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GkeImportList contains a list of GkeImports
type GkeImportList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GkeImport `json:"items"`
}

// Repository type metadata.
var (
	GkeImport_Kind             = "GkeImport"
	GkeImport_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: GkeImport_Kind}.String()
	GkeImport_KindAPIVersion   = GkeImport_Kind + "." + CRDGroupVersion.String()
	GkeImport_GroupVersionKind = CRDGroupVersion.WithKind(GkeImport_Kind)
)

func init() {
	SchemeBuilder.Register(&GkeImport{}, &GkeImportList{})
}
