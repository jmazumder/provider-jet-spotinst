/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoscalerAutoscaleDownObservation struct {
}

type AutoscalerAutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *int64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscalerAutoscaleHeadroomObservation struct {
}

type AutoscalerAutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *int64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	GpuPerUnit *int64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *int64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *int64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscalerResourceLimitsObservation struct {
}

type AutoscalerResourceLimitsParameters struct {

	// +kubebuilder:validation:Optional
	MaxMemoryGib *int64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// +kubebuilder:validation:Optional
	MaxVcpu *int64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type AwsAutoscalerObservation struct {
}

type AwsAutoscalerParameters struct {

	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *int64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *int64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []AutoscalerAutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []AutoscalerAutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendedResourceDefinitions []*string `json:"extendedResourceDefinitions,omitempty" tf:"extended_resource_definitions,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceLimits []AutoscalerResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AwsObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AwsParameters struct {

	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	Autoscaler []AwsAutoscalerParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// +kubebuilder:validation:Optional
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// +kubebuilder:validation:Optional
	ControllerID *string `json:"controllerId,omitempty" tf:"controller_id,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredCapacity *int64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	DrainingTimeout *int64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *int64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceMetadataOptions []InstanceMetadataOptionsParameters `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancers []LoadBalancersParameters `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	// +kubebuilder:validation:Optional
	Logging []LoggingParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	MinSize *int64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	RootVolumeSize *int64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduledTask []ScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// +kubebuilder:validation:Required
	SecurityGroups []*string `json:"securityGroups" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	SpotPercentage *int64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +kubebuilder:validation:Required
	SubnetIds []*string `json:"subnetIds" tf:"subnet_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// +kubebuilder:validation:Optional
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// +kubebuilder:validation:Optional
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type ExportObservation struct {
}

type ExportParameters struct {

	// +kubebuilder:validation:Optional
	S3 []S3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type InstanceMetadataOptionsObservation struct {
}

type InstanceMetadataOptionsParameters struct {

	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// +kubebuilder:validation:Required
	HTTPTokens *string `json:"httpTokens" tf:"http_tokens,omitempty"`
}

type LoadBalancersObservation struct {
}

type LoadBalancersParameters struct {

	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type LoggingObservation struct {
}

type LoggingParameters struct {

	// +kubebuilder:validation:Optional
	Export []ExportParameters `json:"export,omitempty" tf:"export,omitempty"`
}

type RollConfigObservation struct {
}

type RollConfigParameters struct {

	// +kubebuilder:validation:Required
	BatchSizePercentage *int64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`
}

type S3Observation struct {
}

type S3Parameters struct {

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`
}

type ScheduledTaskObservation struct {
}

type ScheduledTaskParameters struct {

	// +kubebuilder:validation:Optional
	ShutdownHours []ShutdownHoursParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Tasks []TasksParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ShutdownHoursObservation struct {
}

type ShutdownHoursParameters struct {

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	TimeWindows []*string `json:"timeWindows" tf:"time_windows,omitempty"`
}

type TagsObservation struct {
}

type TagsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TasksObservation struct {
}

type TasksParameters struct {

	// +kubebuilder:validation:Required
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// +kubebuilder:validation:Required
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type UpdatePolicyObservation struct {
}

type UpdatePolicyParameters struct {

	// +kubebuilder:validation:Optional
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	// +kubebuilder:validation:Optional
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// +kubebuilder:validation:Required
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// AwsSpec defines the desired state of Aws
type AwsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AwsParameters `json:"forProvider"`
}

// AwsStatus defines the observed state of Aws.
type AwsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AwsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Aws is the Schema for the Awss API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinstjet}
type Aws struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AwsSpec   `json:"spec"`
	Status            AwsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AwsList contains a list of Awss
type AwsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Aws `json:"items"`
}

// Repository type metadata.
var (
	Aws_Kind             = "Aws"
	Aws_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Aws_Kind}.String()
	Aws_KindAPIVersion   = Aws_Kind + "." + CRDGroupVersion.String()
	Aws_GroupVersionKind = CRDGroupVersion.WithKind(Aws_Kind)
)

func init() {
	SchemeBuilder.Register(&Aws{}, &AwsList{})
}
